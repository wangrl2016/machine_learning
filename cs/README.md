## Computer Systems: A Programmer's Perspective, 3rd Edition

### 1. A Tour of Computer Systems

#### 1.1 Information Is Bits + Context
#### 1.2 Programs Are Translated by Other Programs into Different Forms
#### 1.3 It Pay to Understand How Compilation Systems Work
#### 1.4 Processors Read and Interpret Instructions Stored in Memory
#### 1.5 Caches Matter
#### 1.6 Storage Devices Form a Hierarchy
#### 1.7 The Operating System Manages the Hardware
#### 1.8 Systems Communicate with Other Systems Using Networks
#### 1.9 Important Themes
#### 1.10 Summary

### 2. Representing and Manipulating Informatino

#### 2.1 Information Storage
#### 2.2 Integer Representation
#### 2.3 Integer Arithmeric
#### 2.4 Floating Point
#### 2.5 Summary

### 3. Machine-Level Representation of Programs

#### 3.1 A Historical Perspective
#### 3.2 Program Encodings
#### 3.3 Data Formats
#### 3.4 Accessing Information
#### 3.5 Arithmetic and Logical Operations
#### 3.6 Control
#### 3.7 Procedures
#### 3.8 Array Allocation and Access
#### 3.9 Heterogeneous Data Structures
#### 3.10 Combining Control and Data in Machine-Level Programs
#### 3.11 Floating-Point Code
#### 3.12 Summary

### 4. Processor Architecture

#### 4.1 The Y86-64 Instruction Set Architecture
#### 4.2 Logic Design and the Hardware Control Language HCL
#### 4.3 Sequential Y86-64 Implementations
#### 4.4 General Principles of Pipelining
#### 4.5 Pipelined Y86-64 Implementations
#### 4.6 Summary

### 5. Optimizing Program Performance

#### 5.1 Capabilities and Limitations of Optimzing Compilers
#### 5.2 Expressing Program Performance
#### 5.3 Program Example
#### 5.4 Eliminating Loop Inefficiencies
#### 5.5 Reducing Procedure Calls
#### 5.6 Eliminating Unneeded Memory References
#### 5.7 Understanding Modern Processors
#### 5.8 Loop Unrolling
#### 5.9 Enhancing Parallelism
#### 5.10 Summary of Results for Optimizing Combining Code
#### 5.11 Some Limiting Factors
#### 5.12 Understanding Memory Performance
#### 5.13 Life in the Real World: Performance Improvement Techniques
#### 5.14 Identifying and Eliminating Performance Bottlenecks
#### 5.15 Summary

### 6. The Memory Hierarchy

#### 6.1 Storage Technologies
#### 6.2 Locality
#### 6.3 The Memory Hierarchy
#### 6.4 Cache Memories
#### 6.5 Writing Cache-Friendly Code
#### 6.6 Putting It Together: The Impact of Caches on Program Performance
#### 6.7 Summary

### 7. Linking

#### 7.1 Compiler Drivers
#### 7.2 Static Linking
#### 7.3 Object Files
#### 7.4 Relocatable Object Files
#### 7.5 Symbols and Symbol Tables
#### 7.6 Symbol Resolution
#### 7.7 Relocation
#### 7.8 Executable Object Files
#### 7.9 Loading Executable Object Files
#### 7.10 Dynamic Linking with Shared Libraries
#### 7.11 Loading and Linking Shared Libraries from Applications
#### 7.12 Position-Independent Code (PIC)
#### 7.13 Library Interpositioning
#### 7.14 Tools for Manipulating Object Files
#### 7.15 Summary

### 8. Exceptional Control Flow

#### 8.1 Exceptions
#### 8.2 Processes
#### 8.3 System Call Error Handling
#### 8.4 Process Control
#### 8.5 Signals
#### 8.6 Nonlocal Jumps
#### 8.7 Tools for Manipulating Processes
#### 8.8 Summary

### 9. Virtual Memory

#### 9.1 Physical and Virtual Addressing
#### 9.2 Address Spaces
#### 9.3 VM as a Tool for Caching
#### 9.4 VM as a tool for Memory Management
#### 9.5 VM as a Tool for Memory Protection
#### 9.6 Address Translation
#### 9.7 Case Study: The Intel Core i7/Linux Memory System
#### 9.8 Memory Mapping
#### 9.9 Dynamic Memory Allocation
#### 9.10 Garbage Collection
#### 9.11 Common Memory-Related Bugs in C Programs
#### 9.12 Summary

### 10. System-Level I/O

#### 10.1 Unix I/O
#### 10.2 Files
#### 10.3 Opening and Closing Files
#### 10.4 Reading and Writing Files
#### 10.5 Robust Reading and Writing with the RIO Package
#### 10.6 Reading File Metadata
#### 10.7 Reading Directory Contents
#### 10.8 Sharing Files
#### 10.9 I/O Redirection
#### 10.10 Standard I/O
#### 10.11 Putting It Together: Which I/O Functions Should I Use?
#### 10.12 Summary

### 11. Network Programming

#### 11.1 The Client-Server Programming Model
#### 11.2 Networks
#### 11.3 The Global IP Internet
#### 11.4 The Sockets Interface
#### 11.5 Web Servers
#### 11.6 Putting It Together: The TINY Web Server
#### 11.7 Summary

### 12. Concurrent Programming

#### 12.1 Concurrent Programming with Processes
#### 12.2 Concurrent Programming with I/O Multiplexing
#### 12.3 Concurrent Programming with Threads
#### 12.4 Shared Variables in Threaded Programs
#### 12.5 Synchronizing Threads with Semaphores
#### 12.6 Using Threads for Parallelism
#### 12.7 Other Concurrency Issues
#### 12.8 Summary

## Introdction to Algorithms

### 1. The Role of Algorithms in Computing

#### 1.1 Algorithms
#### 1.2 Alrogithms as a technology

### 2. Getting Started

#### 2.1 Insertion Sort
#### 2.2 Analyzing Algorithms
#### 2.3 Designing Algorithms

### 3. Characterizing Running Times

#### 3.1 O-notation, and Other-notation
#### 3.2 Asymptotic Notation: Formal Definitions
